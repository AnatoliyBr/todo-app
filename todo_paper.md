# Мой опыт создания TODO REST API сервера

## Подготовка репозитория
Создал директорию проекта.

На Windows (Command Prompt) команды следующие:

```bash
E:
cd E:\HDD\Magistracy\EducationCourses\ITMO\
mkdir todo-app
cd .\todo-app
```

Создал файлы `README.md` и `LICENSE`.

В `README.md` записал структуру проекта.

Также добавил ER-диаграмму базы данных, которую создал в [dbdesigner](https://app.dbdesigner.net) и сохранил в директорию `/assets/images`.

Создал `.gitignore` для игнорирования исполняемого файла приложения `app.exe` и файла с переменными окружения `.env` (`/` обозначает, что будут исключены только файлы, находящиеся в корневой директории проекта).

```
/app.exe
/.env
```

Инициализировал репозиторий, сделал `initial commit` и опубликовал его через IDE:

```bash
git init
git add -A
git commit -m "initial commit"
```

## Конфигурирование приложения
Инициализировал go модуль, чтобы можно было отследить зависимости (библиотеки, используемые в проекте).

```bash
go mod init github.com/AnatoliyBr/todo-app
```

Создал точку входа в приложение - директорию `cmd/app` с файлом `main.go`. Здесь вызывается функция `Run()`.

Создал директорию `internal/app` с файлом `app.go` и определил функцию `Run()`, в которой вызываются конструкторы.

Создал директорию `internal/controller/apiserver` с файлом `apiserver.go`, в котором определил структуру сервера с конструктором (`NewServer`) и методами (`configureRouter`, `StartServer`, `ServeHTTP` (полезен при тестировании)). В той же директории создал файл `config.go`, в котором определил структуру конфига с конструктором (`NewConfig`).

Структура сервера содежит поле роутера (сущность, которая отвечает на http-запросы), в качестве нее использовал роутер из библиотеки **gorilla/mux**, который импортировал командой `go get`.

```bash
go get github.com/gorilla/mux
```

Чтобы не запоминать команды, которые использовались во время разработки и тестирования, фиксировал их в `Makefile`.

<details>
<summary> Работа с Makefile на Windows</summary>

На Windows для работы с `Makefile` пришлось скачать linux-подобное окружение [MinGw](https://sourceforge.net/projects/mingw-w64/). Далее надо было скопировать `mingw32-make.exe`, переименовать утилиту на `make.exe` и указать путь до нее в переменной окружения `Path`.
</details>

Создал в `Makefile` **цель/задачу (target/task)** `build` для сборки приложения. Помним, что цели, не соответствующие файлам, и предназначенные для выполнения набора команд или группировки завимостей, декларируются с помощью `.PHONY`:

```Makefile
.PHONY: build
build:
			go build -v ./cmd/app
```

Также установил эту цель в качестве стандартной задачи по умолчанию:

```Makefile
.DEFAULT_GOAL := build
```

Замечу, что при использовании пробелов вместо табуляции в `Makefile` возникнет ошибка.

Создал директорию `configs` с файлом `apiserver.toml` с помощью которого будет конфигурироваться наше приложение.

Для работы с `.toml` файлами установил библиотеку **BurntSushi/toml**:

```
go get github.com/BurntSushi/toml
```

Чтобы передать путь к конфигурационному файлу с флагом `-config-path` при запуске исполняемого файла приложения `app.exe`, использовал библиотеку `flag`.

А именно, в каталоге `internal/app` определил глобальную переменную `configPath` и функцию `init` перед функцией `Run`. Помним, что в Go функция `init` выполняется автоматически при инициализации пакета и используется для инициализации глобальных переменных.

Чтобы привязать флаг к переменной, вызвал функцию `flag.StringVar` в `init`. Чтобы распарсить флаг, вызывал функцию `flag.Parse` в `Run`, а также функцию `toml.DecodeFile`, чтобы считать параметры из конфигурационного файла.

При запуске исполняемого файла с флагом `-help` выводится информация о доступных флагах.

Написал обработчик `handleHello` для тестового пути `/hello`:

```go
func (s *server) handleHello() http.HandleFunc {
    // some variables

    return func(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, "hello")
    }
}
```

Замечу, что в качестве обработчика удобно использовать не привычную функцию с сигнатурой (`func(w http.ResponseWriter, r *http.Request`), а функцию, возвращающую функцию типа `http.HadleFunc`.

Идея в том, что перед `return` можно определить локальные специфичные типы, которые будут использоваться только в этом обработчике, например, структуру, описывающую формат запроса.

Таким образом, код не захламляется, локальные типы хранятся перед глазами, а вся логика обработки каждого запроса описывается внутри функции, которую возвращаем.

Оправил запрос с помощью утилиты `curl`:

```bash
curl "http://localhost:8080/hello"
```

Создал файл `apiserver_internal_test.go`, суффикс `internal`, так как тестировал приватные методы.

Для модульного тестирования использовал библиотеку **stretchr/testify**, которая предлагает множество удобных методов, которые упрощают написание утверждений (**assert**), например `assert.Equal`.

```bash
go get github.com/stretchr/testify
```

Замечу, что в данном случае не тестируется веб-сервер, как отдельный процесс на отдельном порту, а тестируется лишь функция обработчик.

При этом ей передается объект, который удовлетворяет интерфейсу `http.ResponseWriter` из библиотеки **httptest** - `Recorder`, который создается функцией `httptest.NewRecorder`. В него можно записать ответ и прочесть его в тестах.

Чтобы создать http-запрос, использовал функцию `http.NewRequest`.

Чтобы вызвать функцию обработчик, использовал метод `ServeHTTP(rec, req)`.

Добавил в `Makefile` задачу `test` с флагами `-v` (подробный вывод, протоколирующий все тесты по мере их запуска) и `-race` (детектор состояния гонки):

```Makefile
.PHONY: test
test:
			go test -v -race ./...
```

Можно также добавить флаг `-timeout 30s`, который запускает `panic`, если тестовый бинарный файл работает дольше, чем продолжительность `d` (в частности 30 секунд).

Для обновления файла `go.mod` использовал команду:

```bash
go mod tidy
```

## Создание базы данных в PostgreSQL
Перед определением бизнес-сущностей (entity: `User`, `List`, `Task`) и сущности хранилища (`Store`) провел подготовительную работу по установке СУБД **PostgreSQL**.

Замечу также, что можно было запустить PostgreSQL в **Docker** контейнере.

<details>
    <summary> Работа с PostgreSQL на Windows</summary>

На Windows для работы с PostgreSQL пришлось скачать установщик [Windows installers](https://www.postgresql.org/download/windows/) с официального сайта. Установщик включал PostgreSQL **сервер** и **консольную утилиту** `psql` (точнее файл `runpsql.bat`, который можно скопировать, переименовать и указать путь до него в переменной окружения `Path`, как и в случае с `mingw32-make` утилитой).

Во время установки необходимо выбрать параметр языка (`locale`) равным `C`, иначе сообщения от СУБД будут отображаться не корректно.

Кроме того, во время установки можно выбрать директорию хранения баз данных (`data_directory`). В утилите `psql` текущую директорию можно посмотреть командой `show data_directory;`.

Поменять эту директорию после установки утилиты можно с помощью [следующих команд](https://stackoverflow.com/questions/22596301/how-to-change-postgresql-data-directory).

<details>
    <summary> Команды</summary>

1. Останавливаем службу:

```bash
sc stop postgresql-x64-11
```

2. Меняем директорию у флага `-D`:

```bash
sc config postgresql-x64-11 binPath= "\"C:\Program Files\PostgreSQL\11\bin\pg_ctl.exe\" runservice -N \"postgresql-x64-11\" -D \"E:\HDD\Magistracy\postgre\data" -w"
```

3. Запускаем службу:

```bash
sc start postgresql-x64-11
```

4. Посмотреть статус службы можно с помощью команды:

```bash
sc queryex postgresql-x64-11
```
</details>

</details>

Для корректного отображения информации в командной строке при работе с утилитой `psql`, поменял **кодировку** страницы командой:

```bash
chcp 1251
```

<details>
    <summary> chcp</summary>

* `chcp` - вывести текущую кодировку страницы (по умолчанию **CP866**)
* `chcp 1251` - сменить кодировку страницы на **Windows 1251**
</details>

<details>
    <summary> Команды psql и SQL</summary>

`psql` - интерфейс командной строки к **PostgreSQL**.

* `\copyright` - условия распространения
* `\h` - справка по операторам SQL
* `\?` - справка по командам psql
* `\g` или `;` в конце строки - выполнение запроса
* `\q` - выход

* `\l` - список баз данных
* `\c` {[БД|- ПОЛЬЗОВАТЕЛЬ|- СЕРВЕР|- ПОРТ|-] | conninfo} - подключиться к другой базе данных
    * `\c test_db test_user`
* `\conninfo` - информация о текущем соединении

* `\d` - список таблиц, представлений и последовательностей
* `\d имя` - описание таблицы, представления, последовательности или индекса

* `\du` - список ролей
* `\password имя` - безопасно сменить пароль пользователя

* `CREATE DATABASE название;` - создать БД
* `DROP DATABASE название;` - удалить БД

* `CREATE USER имя;` - создать пользователя
* `CREATE USER имя WITH PASSWORD пароль;` - создать пользователя с паролем
* `DROP USER имя;` - удалить пользователя

</details>

С помощью утилиты `psql` создал нового пользователя `dev` с паролем:

```bash
CREATE USER dev WITH PASSWORD 'qwerty';
```

Создал новую базу данных `todo_dev`:

```bash
CREATE DATABASE todo_dev;
```

## Подключение к базе данных из Go
Для подключения к БД из **Go** использовал стандартную библиотеку `database/sql`. Про особенности работы с данным пакетом кратко написано в [GO DATABASE/SQL TUTORIAL](http://go-database-sql.org/overview.html).

Создал директорию `internal/store` с файлами `db.go` и `config.go`.

В файле `config.go` определил структуру `Config` с полем `DatabaseURL` и конструктор `NewConfig`. 

Поскольку строка подключения к БД (`DatabaseURL`) содержит **пароль** (чувствительные данные), для ее передачи использовал **переменные окружения**.

Для загрузки переменных окружения из `.env` файла в структуру `Config` использовал библиотеку `joho/godotenv`.

```bash
go get github.com/joho/godotenv
```

А именно, вызвал функцию `godotenv.Load` в функции `Run`. А в конструкторе `NewConfig` использовал функцию `os.Getenv`, чтобы извлечь переменную окружения по ключу `DATABASE_URL`.

В файле `db.go` определил функцию `NewDB`, которая принимает `Config` и возвращает указатель `*sql.DB` и ошибку.

Замечу, что тип `sql.DB` - это **не соединение** с БД, это абстракция, которая позволяет не беспокоиться об организации **конкурентного доступа** к хранилищам.

`sql.DB` решает две задачи:
* Он открывает и закрывает соединения с фактической БД через **драйвер**
* Он управляет **пулом подключений**

Для работы с БД необходим драйвер. Для каждой СУБД есть свой драйвер.

В данном случае, я использовал драйвер `lib/pq` для подключения к PostgreSQL.

```bash
go get github.com/lib/pq
```

Чтобы методы библиотеки `lib/pq` не импортировались в проект, библиотеку импортировал **анонимно** (то есть использовать **alias** `_`).

Помним, что если в качестве псевдонима `_`, то будет вызвана функция `init` этого модуля (например, при подключении БД).

Итак, в файле `db.go` импортировал драйвер:

```go
import (
	"database/sql"

	_ "github.com/lib/pq"
)
```

В функции `NewDB` с помощью функции `sql.Open` создал объект `*sql.DB`. А также **пинганул** БД с помощью метода `db.Ping` (помним, что соединение с БД создается лениво, когда происходит первый вызов, поэтому для тестирования существует метод `Ping`).

## Миграции базы данных
Изменения в схеме БД (например, добавление новой таблицы) делаются с помощью **миграции**.

**Версионная миграция БД** - обновление структуры БД от одной версии до другой.

<details>
    <summary> Подробнее про миграции базы данных </summary>

* **Миграция базы данных** - это процесс изменения структуры и содержимого базы данных с целью обновления ее версии, переноса на другую платформу или слияния с другой базой данных.

* Это может включать добавление новых таблиц, изменение существующих таблиц, удаление таблиц или изменение типов данных.

* Миграция может потребоваться при обновлении версии СУБД или изменении платформы, на которой работает база данных.

* Необходимо проводить SQL-миграции с минимальным влиянием на работу приложения, т.е. изменять данные или схему данных таким образом, чтобы приложение продолжало работать и пользователи ничего не замечали.
</details>

Для написания и прогона миграций использовал утилиту `migrate`. Скачал исполняемый файл `.exe` для Windows из [последнего релиза](https://github.com/golang-migrate/migrate/releases) и указал путь до него в переменной окружения `Path`.

<details>
    <summary> Команды migrate</summary>

* `migrate create -ext sql -dir директория название` - создание миграции
* `migrate -path директория -database строка_доступа up` - прогон миграции для обновления БД
* `migrate -path директория -database строка_доступа down` - прогон миграции для отката версии БД
</details>

В моей БД три сущности (пользователи, списки, задачи), соответственно необходимо создать миграции для каждого объекта БД.

<p align="center">
    <img src="/assets/images/er_schema.png" width="800">
</p>

В частности, создал миграцию для работы с таблицей пользователей `create_users` командой:

```bash
migrate create -ext sql -dir migrations create_users
```

В директории `migrations` сгенерировалось два файла: с суффиксом `.up` для обновления БД и `.down` для отката версии БД. В этих файлах пишутся **SQL DDL запросы** с использованием операторов `CREATE`, `ALTER` и `DROP`.

Итак, в `.up` файле прописал SQL-запрос (DDL) для **создания** таблицы пользователей `users`, а в `.down` - для **удаления**.

Всего создал три миграции: `create_users`, `create_lists`, `create_tasks`.

Прогнал миграции командой:

```bash
migrate -path migrations -database "postgres://localhost/todo_dev?sslmode=disable&user=dev&password=qwerty" up
```

<details>
    <summary> Сводка по использованным типам данных </summary>

* `BIGSERAIL` - представляет **автоинкрементирующееся** числовое значение, которое занимает **8 байт**
    * Диапазон: `1` .. `9223372036854775807`
* `BIGINT` - целое число в большом диапазоне, которое занимает **8 байт**.
    * Диапазон: `-9223372036854775808` .. `9223372036854775807`
* `VARCHAR(n)` (`CHARACTER VARYING (n)`) - текст с ограничением по длине (максимальная длина строки может быть ограничена `n` **символов**).
    * Физически максимальный размер любых строк в PostgreSQL ограничен одним гигабайтом (`1GB`).
    * Логическое ограничение на максимальный размер строки (`char(n)`, `varchar(n)`, где `n` - логическое ограничение), задаваемое пользователем для конкретного поля, лимитирует количество символов в строке, а не длину строки в байтах. Поэтому, несмотря на физический лимит на максимальный размер строки в `1GB`, реальное максимальное количество символов в строке может быть меньше, так как различные кодировки символов могут использовать больше одного байта для представления одного символа.
* `TIMESTAMP` - подразумевал `timestamp without time zone` - дата и время (без часового пояса). Размер - **8 байт**.
    * `2004-10-19 10:23:54` - формат ввода **ISO 8601** (рекомендуемый формат).
    * `2004-10-19 10:23:54.789` - формат ввода **ISO 8601** с наносекундами.
    * `2004-10-19T10:23:54` - альтернативный формат **ISO 8601** для совместимости с **RFC 3339** и другими СУБД.
</details>

## Сущность хранилища (Store)
Хранилище (`Store`) - интерфейс, который скрывает детали реализации и предоставляет публичные методы, с помощью которых осуществляется работа с репозиторями из внешнего мира.

Репозитории (`UserRepository`, `ListRepository`, `TaskRepository`) соответствуют трем таблицам в нашей БД.

## Полезные ссылки
* [REST API на Golang](https://www.youtube.com/playlist?list=PLehOyJfJkFkJ5m37b4oWh783yzVlHdnUH)