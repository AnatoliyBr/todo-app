# Мой опыт создания TODO REST API сервера

## Подготовка репозитория
Создал директорию проекта.

На Windows (Command Prompt) команды следующие:

```bash
E:
cd E:\HDD\Magistracy\EducationCourses\ITMO\
mkdir todo-app
cd .\todo-app
```

Создал файлы `README.md` и `LICENSE`.

В `README.md` записал структуру проекта.

Также добавил ER-диаграмму базы данных, которую создал в [dbdesigner](https://app.dbdesigner.net) и сохранил в директорию `/assets/images`.

Создал `.gitignore` для игнорирования исполняемого файла приложения `app.exe` и файла с переменными окружения `.env` (`/` обозначает, что будут исключены только файлы, находящиеся в корневой директории проекта).

```
/app.exe
/.env
```

Инициализировал репозиторий, сделал `initial commit` и опубликовал его через IDE:

```bash
git init
git add -A
git commit -m "initial commit"
```

## Конфигурирование приложения
Инициализировал go модуль, чтобы можно было отследить зависимости (библиотеки, используемые в проекте).

```bash
go mod init github.com/AnatoliyBr/todo-app
```

Создал точку входа в приложение - директорию `cmd/app` с файлом `main.go`. Здесь вызывается функция `Run()`.

Создал директорию `internal/app` с файлом `app.go` и определил функцию `Run()`, в которой вызываются конструкторы.

Создал директорию `internal/controller/apiserver` с файлом `apiserver.go`, в котором определил структуру сервера с конструктором (`NewServer`) и методами (`configureRouter`, `StartServer`, `ServeHTTP` (полезен при тестировании)). В той же директории создал файл `config.go`, в котором определил структуру конфига с конструктором (`NewConfig`).

Структура сервера содежит поле роутера (сущность, которая отвечает на http-запросы), в качестве нее использовал роутер из библиотеки **gorilla/mux**, который импортировал командой `go get`.

```bash
go get github.com/gorilla/mux
```

Чтобы не запоминать команды, которые использовались во время разработки и тестирования, фиксировал их в `Makefile`.

<details>
<summary> Работа с Makefile в Windows</summary>

На Windows для работы с `Makefile` пришлось скачать linux-подобное окружение [MinGw](https://sourceforge.net/projects/mingw-w64/). Далее надо было скопировать `mingw32-make.exe`, переименовать утилиту на `make.exe` и указать путь до нее в переменной окружения `Path`.
</details>

Создал в `Makefile` **цель/задачу (target/task)** `build` для сборки приложения. Помним, что цели, не соответствующие файлам, и предназначенные для выполнения набора команд или группировки завимостей, декларируются с помощью `.PHONY`:

```Makefile
.PHONY: build
build:
			go build -v ./cmd/app
```

Также установил эту цель в качестве стандартной задачи по умолчанию:

```Makefile
.DEFAULT_GOAL := build
```

Замечу, что при использовании пробелов вместо табуляции в `Makefile` возникнет ошибка.

Создал директорию `configs` с файлом `apiserver.toml` с помощью которого будет конфигурироваться наше приложение.

Для работы с `.toml` файлами установил библиотеку **BurntSushi/toml**:

```
go get github.com/BurntSushi/toml
```

Чтобы передать путь к конфигурационному файлу с флагом `-config-path` при запуске исполняемого файла приложения `app.exe`, использовал библиотеку `flag`.

А именно, в каталоге `internal/app` определил глобальную переменную `configPath` и функцию `init` перед функцией `Run`. Помним, что в Go функция `init` выполняется автоматически при инициализации пакета и используется для инициализации глобальных переменных.

Чтобы привязать флаг к переменной, вызвал функцию `flag.StringVar` в `init`. Чтобы распарсить флаг, вызывал функцию `flag.Parse` в `Run`, а также функцию `toml.DecodeFile`, чтобы считать параметры из конфигурационного файла.

При запуске исполняемого файла с флагом `-help` выводится информация о доступных флагах.

Написал обработчик `handleHello` для тестового пути `/hello`:

```go
func (s *server) handleHello() http.HandleFunc {
    // some variables

    return func(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, "hello")
    }
}
```

Замечу, что в качестве обработчика удобно использовать не привычную функцию с сигнатурой (`func(w http.ResponseWriter, r *http.Request`), а функцию, возвращающую функцию типа `http.HadleFunc`.

Идея в том, что перед `return` можно определить локальные специфичные типы, которые будут использоваться только в этом обработчике, например, структуру, описывающую формат запроса.

Таким образом, код не захламляется, локальные типы хранятся перед глазами, а вся логика обработки каждого запроса описывается внутри функции, которую возвращаем.

Оправил запрос с помощью утилиты `curl`:

```bash
curl "http://localhost:8080/hello"
```

Создал файл `apiserver_internal_test.go`, суффикс `internal`, так как тестировал приватные методы.

Для модульного тестирования использовал библиотеку **stretchr/testify**, которая предлагает множество удобных методов, которые упрощают написание утверждений (**assert**), например `assert.Equal`.

```bash
go get github.com/stretchr/testify
```

Замечу, что в данном случае не тестируется веб-сервер, как отдельный процесс на отдельном порту, а тестируется лишь функция обработчик.

При этом ей передается объект, который удовлетворяет интерфейсу `http.ResponseWriter` из библиотеки **httptest** - `Recorder`, который создается функцией `httptest.NewRecorder`. В него можно записать ответ и прочесть его в тестах.

Чтобы создать http-запрос, использовал функцию `http.NewRequest`.

Чтобы вызвать функцию обработчик, использовал метод `ServeHTTP(rec, req)`.

Добавил в `Makefile` задачу `test` с флагами `-v` (подробный вывод, протоколирующий все тесты по мере их запуска) и `-race` (детектор состояния гонки):

```Makefile
.PHONY: test
test:
			go test -v -race ./...
```

Можно также добавить флаг `-timeout 30s`, который запускает `panic`, если тестовый бинарный файл работает дольше, чем продолжительность `d` (в частности 30 секунд).

Для обновления файла `go.mod` использовал команду:

```bash
go mod tidy
```

## Работа с базой данных

## Полезные ссылки
* [REST API на Golang](https://www.youtube.com/playlist?list=PLehOyJfJkFkJ5m37b4oWh783yzVlHdnUH)