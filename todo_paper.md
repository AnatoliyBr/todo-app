# Мой опыт создания TODO REST API сервера

## Подготовка репозитория
Создал директорию проекта.

На Windows (Command Prompt) команды следующие:

```bash
E:
cd E:\HDD\Magistracy\EducationCourses\ITMO\
mkdir todo-app
cd .\todo-app
```

Создал файлы `README.md` и `LICENSE`.

В `README.md` записал структуру проекта.

Также добавил ER-диаграмму базы данных, которую создал в [dbdesigner](https://app.dbdesigner.net) и сохранил в директорию `/assets/images`.

Создал `.gitignore` для игнорирования исполняемого файла приложения `app.exe` и файла с переменными окружения `.env` (`/` обозначает, что будут исключены только файлы, находящиеся в корневой директории проекта).

```
/app.exe
/.env
```

Инициализировал репозиторий, сделал `initial commit` и опубликовал его через IDE:

```bash
git init
git add -A
git commit -m "initial commit"
```

## Конфигурирование приложения
Инициализировал go модуль, чтобы можно было отследить зависимости (библиотеки, используемые в проекте).

```bash
go mod init github.com/AnatoliyBr/todo-app
```

Создал точку входа в приложение - директорию `cmd/app` с файлом `main.go`. Здесь вызывается функция `Run()`.

Создал директорию `internal/app` с файлом `app.go` и определил функцию `Run()`, в которой вызываются конструкторы.

Создал директорию `internal/controller/apiserver` с файлом `apiserver.go`, в котором определил структуру сервера с конструктором (`NewServer`) и методами (`configureRouter`, `StartServer`, `ServeHTTP` (полезен при тестировании)). В той же директории создал файл `config.go`, в котором определил структуру конфига с конструктором (`NewConfig`).

Структура сервера содежит поле роутера (сущность, которая отвечает на http-запросы), в качестве нее использовал роутер из библиотеки **gorilla/mux**, который импортировал командой `go get`.

```bash
go get github.com/gorilla/mux
```

Чтобы не запоминать команды, которые использовались во время разработки и тестирования, фиксировал их в `Makefile`.

<details>
<summary> Работа с Makefile на Windows</summary>

На Windows для работы с `Makefile` пришлось скачать linux-подобное окружение [MinGw](https://sourceforge.net/projects/mingw-w64/). Далее надо было скопировать `mingw32-make.exe`, переименовать утилиту на `make.exe` и указать путь до нее в переменной окружения `Path`.
</details>

Создал в `Makefile` **цель/задачу (target/task)** `build` для сборки приложения. Помним, что цели, не соответствующие файлам, и предназначенные для выполнения набора команд или группировки завимостей, декларируются с помощью `.PHONY`:

```Makefile
.PHONY: build
build:
			go build -v ./cmd/app
```

Также установил эту цель в качестве стандартной задачи по умолчанию:

```Makefile
.DEFAULT_GOAL := build
```

Замечу, что при использовании пробелов вместо табуляции в `Makefile` возникнет ошибка.

Создал директорию `configs` с файлом `apiserver.toml` с помощью которого будет конфигурироваться наше приложение.

Для работы с `.toml` файлами установил библиотеку **BurntSushi/toml**:

```
go get github.com/BurntSushi/toml
```

Чтобы передать путь к конфигурационному файлу с флагом `-config-path` при запуске исполняемого файла приложения `app.exe`, использовал библиотеку `flag`.

А именно, в каталоге `internal/app` определил глобальную переменную `configPath` и функцию `init` перед функцией `Run`. Помним, что в Go функция `init` выполняется автоматически при инициализации пакета и используется для инициализации глобальных переменных.

Чтобы привязать флаг к переменной, вызвал функцию `flag.StringVar` в `init`. Чтобы распарсить флаг, вызывал функцию `flag.Parse` в `Run`, а также функцию `toml.DecodeFile`, чтобы считать параметры из конфигурационного файла.

При запуске исполняемого файла с флагом `-help` выводится информация о доступных флагах.

Написал обработчик `handleHello` для тестового пути `/hello`:

```go
func (s *server) handleHello() http.HandleFunc {
    // some variables

    return func(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, "hello")
    }
}
```

Замечу, что в качестве обработчика удобно использовать не привычную функцию с сигнатурой (`func(w http.ResponseWriter, r *http.Request`), а функцию, возвращающую функцию типа `http.HadleFunc`.

Идея в том, что перед `return` можно определить локальные специфичные типы, которые будут использоваться только в этом обработчике, например, структуру, описывающую формат запроса.

Таким образом, код не захламляется, локальные типы хранятся перед глазами, а вся логика обработки каждого запроса описывается внутри функции, которую возвращаем.

Оправил запрос с помощью утилиты `curl`:

```bash
curl "http://localhost:8080/hello"
```

Создал файл `apiserver_internal_test.go`, суффикс `internal`, так как тестировал приватные методы.

Для модульного тестирования использовал библиотеку **stretchr/testify**, которая предлагает множество удобных методов, которые упрощают написание утверждений (**assert**), например `assert.Equal`.

```bash
go get github.com/stretchr/testify
```

Замечу, что в данном случае не тестируется веб-сервер, как отдельный процесс на отдельном порту, а тестируется лишь функция обработчик.

При этом ей передается объект, который удовлетворяет интерфейсу `http.ResponseWriter` из библиотеки **httptest** - `Recorder`, который создается функцией `httptest.NewRecorder`. В него можно записать ответ и прочесть его в тестах.

Чтобы создать http-запрос, использовал функцию `http.NewRequest`.

Чтобы вызвать функцию обработчик, использовал метод `ServeHTTP(rec, req)`.

Добавил в `Makefile` задачу `test` с флагами `-v` (подробный вывод, протоколирующий все тесты по мере их запуска) и `-race` (детектор состояния гонки):

```Makefile
.PHONY: test
test:
			go test -v -race ./...
```

Можно также добавить флаг `-timeout 30s`, который запускает `panic`, если тестовый бинарный файл работает дольше, чем продолжительность `d` (в частности 30 секунд).

Для обновления файла `go.mod` использовал команду:

```bash
go mod tidy
```

## Создание базы данных в PostgreSQL
Перед определением бизнес-сущностей (entity: `User`, `List`, `Task`) и сущности хранилища (`Store`) провел подготовительную работу по установке СУБД **PostgreSQL**.

Замечу также, что можно было запустить PostgreSQL в **Docker** контейнере.

<details>
    <summary> Работа с PostgreSQL на Windows</summary>

На Windows для работы с PostgreSQL пришлось скачать установщик [Windows installers](https://www.postgresql.org/download/windows/) с официального сайта. Установщик включал PostgreSQL **сервер** и **консольную утилиту** `psql` (точнее файл `runpsql.bat`, который можно скопировать, переименовать и указать путь до него в переменной окружения `Path`, как и в случае с `mingw32-make` утилитой).

Во время установки необходимо выбрать параметр языка (`locale`) равным `C`, иначе сообщения от СУБД будут отображаться не корректно.

Кроме того, во время установки можно выбрать директорию хранения баз данных (`data_directory`). В утилите `psql` текущую директорию можно посмотреть командой `show data_directory;`.

Поменять эту директорию после установки утилиты можно с помощью [следующих команд](https://stackoverflow.com/questions/22596301/how-to-change-postgresql-data-directory).

<details>
    <summary> Команды</summary>

1. Останавливаем службу:

```bash
sc stop postgresql-x64-11
```

2. Меняем директорию у флага `-D`:

```bash
sc config postgresql-x64-11 binPath= "\"C:\Program Files\PostgreSQL\11\bin\pg_ctl.exe\" runservice -N \"postgresql-x64-11\" -D \"E:\HDD\Magistracy\postgre\data" -w"
```

3. Запускаем службу:

```bash
sc start postgresql-x64-11
```

4. Посмотреть статус службы можно с помощью команды:

```bash
sc queryex postgresql-x64-11
```
</details>

</details>

Для корректного отображения информации в командной строке при работе с утилитой `psql`, поменял **кодировку** страницы командой:

```bash
chcp 1251
```

<details>
    <summary> chcp</summary>

* `chcp` - вывести текущую кодировку страницы (по умолчанию **CP866**)
* `chcp 1251` - сменить кодировку страницы на **Windows 1251**
</details>

<details>
    <summary> Команды psql и SQL</summary>

`psql` - интерфейс командной строки к **PostgreSQL**.

* `\copyright` - условия распространения
* `\h` - справка по операторам SQL
* `\?` - справка по командам psql
* `\g` или `;` в конце строки - выполнение запроса
* `\q` - выход

* `\l` - список баз данных
* `\c` {[БД|- ПОЛЬЗОВАТЕЛЬ|- СЕРВЕР|- ПОРТ|-] | conninfo} - подключиться к другой базе данных
    * `\c test_db test_user`
* `\conninfo` - информация о текущем соединении

* `\d` - список таблиц, представлений и последовательностей
* `\d имя` - описание таблицы, представления, последовательности или индекса

* `\du` - список ролей
* `\password имя` - безопасно сменить пароль пользователя

* `CREATE DATABASE название;` - создать БД
* `DROP DATABASE название;` - удалить БД

* `CREATE USER имя;` - создать пользователя
* `CREATE USER имя WITH PASSWORD пароль;` - создать пользователя с паролем
* `DROP USER имя;` - удалить пользователя

</details>

С помощью утилиты `psql` создал нового пользователя `dev` с паролем:

```bash
CREATE USER dev WITH PASSWORD 'qwerty';
```

Создал новую базу данных `todo_dev`:

```bash
CREATE DATABASE todo_dev;
```

## Подключение к базе данных из Go
Для подключения к БД из **Go** использовал стандартную библиотеку `database/sql`. Про особенности работы с данным пакетом кратко написано в [GO DATABASE/SQL TUTORIAL](http://go-database-sql.org/overview.html).

Создал директорию `internal/store` с файлами `db.go` и `config.go`.

В файле `config.go` определил структуру `Config` с полем `DatabaseURL` и конструктор `NewConfig`. 

Поскольку строка подключения к БД (`DatabaseURL`) содержит **пароль** (чувствительные данные), для ее передачи использовал **переменные окружения**.

Для загрузки переменных окружения из `.env` файла в структуру `Config` использовал библиотеку `joho/godotenv`.

```bash
go get github.com/joho/godotenv
```

А именно, вызвал функцию `godotenv.Load` в функции `Run`. А в конструкторе `NewConfig` использовал функцию `os.Getenv`, чтобы извлечь переменную окружения по ключу `DATABASE_URL`.

В файле `db.go` определил функцию `NewDB`, которая принимает `Config` и возвращает указатель `*sql.DB` и ошибку.

Замечу, что тип `sql.DB` - это **не соединение** с БД, это абстракция, которая позволяет не беспокоиться об организации **конкурентного доступа** к хранилищам.

`sql.DB` решает две задачи:
* Он открывает и закрывает соединения с фактической БД через **драйвер**
* Он управляет **пулом подключений**

Для работы с БД необходим драйвер. Для каждой СУБД есть свой драйвер.

В данном случае, я использовал драйвер `lib/pq` для подключения к PostgreSQL.

```bash
go get github.com/lib/pq
```

Чтобы методы библиотеки `lib/pq` не импортировались в проект, библиотеку импортировал **анонимно** (то есть использовать **alias** `_`).

Помним, что если в качестве псевдонима `_`, то будет вызвана функция `init` этого модуля (например, при подключении БД).

Итак, в файле `db.go` импортировал драйвер:

```go
import (
	"database/sql"

	_ "github.com/lib/pq"
)
```

В функции `NewDB` с помощью функции `sql.Open` создал объект `*sql.DB`. А также **пинганул** БД с помощью метода `db.Ping` (помним, что соединение с БД создается лениво, когда происходит первый вызов, поэтому для тестирования существует метод `Ping`).

## Миграции базы данных
Изменения в схеме БД (например, добавление новой таблицы) делаются с помощью **миграции**.

**Версионная миграция БД** - обновление структуры БД от одной версии до другой.

<details>
    <summary> Подробнее про миграции базы данных </summary>

* **Миграция базы данных** - это процесс изменения структуры и содержимого базы данных с целью обновления ее версии, переноса на другую платформу или слияния с другой базой данных.

* Это может включать добавление новых таблиц, изменение существующих таблиц, удаление таблиц или изменение типов данных.

* Миграция может потребоваться при обновлении версии СУБД или изменении платформы, на которой работает база данных.

* Необходимо проводить SQL-миграции с минимальным влиянием на работу приложения, т.е. изменять данные или схему данных таким образом, чтобы приложение продолжало работать и пользователи ничего не замечали.
</details>

Для написания и прогона миграций использовал утилиту `migrate`. Скачал исполняемый файл `.exe` для Windows из [последнего релиза](https://github.com/golang-migrate/migrate/releases) и указал путь до него в переменной окружения `Path`.

<details>
    <summary> Команды migrate</summary>

* `migrate create -ext sql -dir директория название` - создание миграции
* `migrate -path директория -database строка_доступа up` - прогон миграции для обновления БД
* `migrate -path директория -database строка_доступа down` - прогон миграции для отката версии БД
</details>

В моей БД три сущности (пользователи, списки, задачи), соответственно необходимо создать миграции для каждого объекта БД.

<p align="center">
    <img src="/assets/images/er_schema.png" width="800">
</p>

В частности, создал миграцию для работы с таблицей пользователей `create_users` командой:

```bash
migrate create -ext sql -dir migrations create_users
```

В директории `migrations` сгенерировалось два файла: с суффиксом `.up` для обновления БД и `.down` для отката версии БД. В этих файлах пишутся **SQL DDL запросы** с использованием операторов `CREATE`, `ALTER` и `DROP`.

Итак, в `.up` файле прописал SQL-запрос (DDL) для **создания** таблицы пользователей `users`, а в `.down` - для **удаления**.

Всего создал три миграции: `create_users`, `create_lists`, `create_tasks`.

Прогнал миграции командой:

```bash
migrate -path migrations -database "postgres://localhost/todo_dev?sslmode=disable&user=dev&password=qwerty" up
```

<details>
    <summary> Сводка по использованным типам данных </summary>

* `BIGSERAIL` - представляет **автоинкрементирующееся** числовое значение, которое занимает **8 байт**
    * Диапазон: `1` .. `9223372036854775807`
* `BIGINT` - целое число в большом диапазоне, которое занимает **8 байт**.
    * Диапазон: `-9223372036854775808` .. `9223372036854775807`
* `VARCHAR(n)` (`CHARACTER VARYING (n)`) - текст с ограничением по длине (максимальная длина строки может быть ограничена `n` **символов**).
    * Физически максимальный размер любых строк в PostgreSQL ограничен одним гигабайтом (`1GB`).
    * Логическое ограничение на максимальный размер строки (`char(n)`, `varchar(n)`, где `n` - логическое ограничение), задаваемое пользователем для конкретного поля, лимитирует количество символов в строке, а не длину строки в байтах. Поэтому, несмотря на физический лимит на максимальный размер строки в `1GB`, реальное максимальное количество символов в строке может быть меньше, так как различные кодировки символов могут использовать больше одного байта для представления одного символа.
* `TIMESTAMP` - подразумевал `timestamp without time zone` - дата и время (без часового пояса). Размер - **8 байт**.
    * `2004-10-19 10:23:54` - формат ввода **ISO 8601** (рекомендуемый формат).
    * `2004-10-19 10:23:54.789` - формат ввода **ISO 8601** с наносекундами.
    * `2004-10-19T10:23:54` - альтернативный формат **ISO 8601** для совместимости с **RFC 3339** и другими СУБД.
</details>

## Бизнес-сущности (слой Entity)
Слой `Entity` содержит **модели данных**, то есть структуры (с методами), которые являются представлениями записей в БД. Слой абсолютно независим и переносим.

Создал директорию `internal/entity` с файлами: `user.go`, `list.go`, `task.go`.

В файле `user.go` определил структуру **пользователя** с полями, соответствующими таблице `users` в БД. Также добавил дополнительное поле `Password` с не хэшированным паролем. Прописал `json` тэги для сериализации (процесса перевода структуры данных в битовую последовательность), при этом у поля `Password` установил опцию `omitempty`, чтобы пропускать пустое поле `Password`, а у поля `EncryptedPassword` - `-`, чтобы всегда пропускать поле `EncryptedPassword`.

В файле `list.go` определил структуру **списка** с полями, соответствующими таблице `lists` в БД.

В файле `task.go` определил структуру **задачи** с полями, соответствующими таблице `tasks` в БД. Поле `Deadline` будет храниться в формате `time.Time`, точнее в структуре `TimeISO`, для которой были переопределены методы `MarshalJSON` и `UnmarshalJSON`.

Это нужно, чтобы кодировать и декодировать дату и время в формате **ISO 8601** (в библиотеке `time` этот формат соответствует константе `time.DateTime` вида `2006-01-02 15:04:05`). Помним, что по умолчанию формат **RFC 3339**.

<details>
    <summary> Полезные функции/методы библиотеки time</summary>

* `func (t Time) MarshalJSON() ([]byte, error)` - реализует интерфейс `encoding.TextMarshaler`. `Time` - это строка в кавычках в формате **RFC 3339** с точностью до секунды.
* `func (t *Time) UnmarshalJSON(data []byte) error` - реализует интерфейс `encoding.TextUnmarshaler`. `Time` - это строка в кавычках в формате **RFC 3339** с точностью до секунды.

* `func Parse(layout, value string) (Time, error)` - разбирает отформатированную строку и возвращает значение времени, которое она представляет. 
    * `layout` - формат ввода. В качестве него можно передать константу `time.DateTime` (`2006-01-02 15:04:05`), формат которой совпадает с форматом метки времени в PosgreSQL.
* `func (t Time) Format(layout string) string` - возвращает текстовое представление значения времени, отформатированное в соответствии с форматом вывода (`layout`).
</details>

Итак, создал в директории `internal/entity` файл `timeiso.go`, в котором определил структуру времени с методами `MarshalJSON` и `UnmarshalJSON`.

## Интерфейсы хранилища (Store) и репозиториев
Сами модели данных не знают, как они сохраняются в БД, как они считываются из БД. За работу с БД отвечают **репозитории**. В данном проекте всего три репозитория (`UserRepository`, `ListRepository`, `TaskRepository`), которые соответствуют трем таблицам в БД.

Для удобства создал сущность **хранилища**, состоящее из репозиториев.

Хранилище (`Store`) - интерфейс, который скрывает детали реализации и предоставляет публичные методы, с помощью которых осуществляется работа с репозиторями из внешнего мира.

Итак, создал в директории `internal/store` файл `interfaces.go`, в котором описал **интерфейс хранилища** и **интерфейсы репозиториев**. 

В интерфейсе `Store` всего три метода: `User`, `List`, `Task`. Для удобства разработки сначала добавил только один метод `User`, который возвращает интерфейс `UserRepository` - репозиторий для работы с таблицей пользователей.

В интерфейсе `UserRepository` определил набор сигнатур методов: `Create`, `FindByID`, `FindByEmail`.

## Реализации интерфейсов хранилища (Store) и репозиториев
В директории `internal/store` создал две директории `sqlstore` и `teststore` - это две реализации интерфейсов.

`sqlstore` будет непосредственно взаимодействовать с БД, а `teststore` - реализация тестового хранилища (mock).

Запросы непосредственно к БД нужны для тестов SQL-запросов внутри пакета `sqlstore`.

А дополнительная реализация `teststore` нужна при тестировании **вне пакета** `store` (например, `controller`), чтобы не делать реальные запросы к БД, а подменять БД на фейковую **in-memory** реализацию, которая хранит информацию в памяти (например, в map'е).

Это позволит упростить тесты, сделать их быстрее, дает возможность запускать их параллельно.

Итак, в директории `internal/store/sqlstore` создал файлы `userrepository.go` и `store.go`.

В файле `userrepository.go` определяем структуру - реализацию интерфейса `UserRepository` с полем типа `*sql.DB`, конструктором `NewUserRepository` и соответствующими методами.

В файле `store.go` определяем структуру - реализацию интерфейса `Store` с полем типа `*UserRepository`, конструктором `NewStore` и методом `User`, который возвращает интерфейс `UserRepository`.

<details>
    <summary> Замечания по реализации методов Create, FindByID, FindByEmail</summary>

1. Метод `Create`
    * Перед выполнением запроса в БД необходимо **валидировать модель пользователя** и **хэшировать пароль**, то есть требуется реализовать два дополнительных метода для структуры `User`.
    * Для запросов в БД, возвращающих только **одну строку** (single-row queries), существует короткая запись (связка методов `QueryRow` и `Scan`).
    * При добавлении строки в таблицу можно получить сгенерированный СУБД уникальный идентификатор этой строки (например, `user_id`) или значение любого поля, которое имеет значение по умолчанию, с помощью оператора `RETURNING`.

</details>

## Тестирование репозиториев в пакете sqlstore
Помним, что хорошей практикой является написание тестов сразу после определения метода.

Для тестирования методов `Create`, `FindByEmail`, `FindByID` (и для методов других репозиториев, которые работают с БД) лучше использовать **реальную БД** , потому что ошибки могут возникнуть на уровне SQL-запросов, а с моками это **не отследить**.

Таким образом, перед тестированием необходимо было провести подготовительную работу.

В частности, создал тестовую БД `todo_test` :

```bash
CREATE DATABASE todo_test;
```

Прогнал для нее миграции:

```bash
migrate -path migrations -database "postgres://localhost/todo_test?sslmode=disable&user=dev&password=qwerty" up
```

Итак, в директории `internal/store/sqlstore` создал файл `helper.go`, в котором определил вспомогательную функцию (**хэлпер**) `TestDB`, который будет возвращать объект `*sql.DB` для подключения к тестовой БД и **callback-функцию**, с помощью которой можно **очистить все таблицы**, которые будут заполняться в процессе тестов, чтобы новые тесты работали с пустой БД.

<details>
    <summary> Замечания по реализации хэлпера TestDB и библиотеке testing</summary>

* тип `testing.T` - тип, который передается всем тестовым функциям для управления состоянием тестов и поддержки форматированных логов для тестов.
* `t.Helper` - помечает вызываемую функцию, как хэлпер-функцию (она пропускается при выводе информации).
    * В частности, `t.Helper` вызывается в начале хэлпера `TestDB`.
* `t.Fatal` - тест провален.

* Чтобы удалить все строки из набора таблиц, а также из таблиц, ссылающихся по внешнему ключу на заданные таблицы, использовал команду `TRUNCATE` вместе с параметром `CASCADE`. Запрос обернул в функцию `fmt.Sprintf` и выполнил его с помощью метода `Exec`, поскольку запрос ничего не возвращает.
</details>

Кроме этого, создал файл `sqlstore_test.go`, в котором определил переменную `testDatabaseURL` и переопределил функцию `TestMain` из библиотеки `testing`, в которой происходит чтение переменной окружения `TEST_DATABASE_URL` (добавил ее в `.env` файл).

Функция `TestMain` вызывается один раз перед всеми тестами в конкретном пакете, поэтому в ней удобно проводить разовые манипуляции, в частности считать строку доступа до тестовой БД `todo_test`.

Замечу, что в функцию `TestMain` передается объект типа `*testing.M` - это тип, передаваемый функции `TestMain` для выполнения фактических тестов.

Помимо хэлпера `TestDB` создал хэлпер `TestUser`. А именно, в директории `internal/entity` создал файл `helper.go`, в котором определил хэлпер-функцию `TestUser`, которая нужна, чтобы в тестах каждый раз заново не определять структуру пользователя (не заполнять поля `Email` и `Password`).

После подготовительной части создал файл `userrepository_test.go`, в котором написаны тесты для методов структуры `UserRepository`.

<details>
    <summary> Полезные функции библиотеки stretchr/testify/assert</summary>

* `assert.NotNil` - проверка, что переданный указатель не `nil`.
* `assert.NotEmpty` - проверка, что переданный объект не пустой (не `nil`, `""`, `false`, `0`).
* `assert.NoError` - проверка, что переданная функция не вернула ошибку (а например, `nil`).
* `assert.Error` - проверка, что переданная функция вернула ошибку.
* `assert.Equal` - проверяет, что объекты одинаковы (например, ожидаемое и фактическое значение).
</details>

## Валидация модели пользователя и хэширование пароля
Помним, что в методе `Create` перед выполнением запроса в БД необходимо **валидировать модель пользователя** и **хэшировать пароль**, то есть требуется реализовать два дополнительных метода для структуры `User`.

В директории `internal/entity` в файле `user.go` определил метод `Validate`, в котором проверяется пользовательский ввод, чтобы нельзя было отправить что угодно и оно бы сохранилось в БД.

Кроме того, чтобы не хранить пароль в БД в открытом виде, определил callback-метод `BeforeCreate`, который вызывается при каждой попытке сохранить пользователя в БД с помощью метода `Create` репозитория `UserRepository`, а также приватную функцию `encryptString` для непосредственно шифрования строки `Password`.

Для хэширования использовал пакет `bcrypt` из библиотеки `x/crypto`:

```bash
go get golang.org/x/crypto
```

Чтобы сгенерировать хэш пароля с заданной стоимостью вычисления (параметр `cost`), использовал функцию `bcrypt.GenerateFromPassword`. В качестве значения `cost` была взята константа `bcrypt.MinCost = 4` (`bcrypt.DefaultCost = 10`).

<details>
    <summary> Замечания по параметру cost </summary>

* Параметр `cost` - это стоимость вычисления хэша.
* `cost` влияет на количество операций при генерации хэша, как степень числа 2.
    * При `cost = 10` будет $2^{cost} = 2^{10}$ повторений алгоритма для вычисления.
* Чем **выше стоимость** вычисления хэширующего алгоритма, тем **больше времени** требуется для взлома его вывода методом полного перебора (brute force).
* Таким образом, `cost` определяет количество циклов, через которое будет пропущена исходная информация (это **замедляется** процесс хэширования).
</details>

Добавил в файл `user_test.go` тест `TestUser_BeforeCreate` для метода `BeforeCreate`.

Для валидации модели данных пользователя использовал библиотеки `go-ozzo/ozzo-validation` и `go-ozzo/ozzo-validation/is`:

```bash
go get github.com/go-ozzo/ozzo-validation
go get github.com/go-ozzo/ozzo-validation/is
```

Импортировал их в файл `user.go`:

```go
import (
    validation "github.com/go-ozzo/ozzo-validation"
    "github.com/go-ozzo/ozzo-validation/is"
)
```

<details>
    <summary> Замечания по реализации метода Validate</summary>

Для валидации полей структуры `User` использовал функцию `validation.ValidateStruct`, в которую передал указатель на структуру `User` и объекты типа `*validation.FieldRules`, которые возвращает функция `validation.Field`, принимающая указатель на поле структуры, которое необходимо валидировать, и правила проверки.

В частности, поле `Email` **обязательное** (правило `validation.Required`) и является **почтовым адресом** (правило `is.Email` из библиотеки `is`).

Для валидации пароля пользователя `Password` создал **кастомное правило** с помощью функции `validation.By`.

Идея в том, что **при добавлении** пользователя в БД поле пароля `Password` обязательно, но **при чтения** пользователя из БД в `Password` ничего не записывается, так как пароль не хранится в открытом виде в БД. Следовательно, если поле будет обязательным, то при попытке изменить пользователя и сохранить его в БД, модель будет не валидна, поскольку поле `Password` будет пустым.

Итак, создал в директории `internal/entity` файл `validations.go`, в котором определил функцию `requiredIF`, которая устанавливает условие на обязательность поля и возвращает `validation.RuleFunc`. В данном случае, если поле `EncryptedPassword` еще пустое (`""`), то в функцию `requiredIF` передается `true` и правило принимает значение `validation.Required`.

Кроме этого, проверил длину пароля правилом `validation.Length`.
</details>

Также добавил в файл `user_test.go` тест `TestUser_Validate` для метода `Validate`.

<details>
    <summary> Замечание по реализации модульных тестов</summary>

Для табличных тестов:
1. Определил **срез анонимных структур** `testCases` с полем названия **sub-теста** (`name`) и дополнительными полями.
    * Например, для теста метода `Validate` дополнительные поля:
        * `u` - функция, которая возвращает пользователя, внутри нее можно делать манипуляции над тестовым валидным пользователем.
        * `isValid` - `bool`.
2. Создал **цикл**, который итерирует по всем sub-тестам и запускает их.

Псевдо-код unit-тестов:

```go
func TestStruct_Func(t *testing.T) {
    testCases := []struct {
        name: string,
        // ...
    }

    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            // ...
        })
    }
}
```
</details> 

В директории `internal/store/sqlstore` в файле `userrepository.go` вызвал методы Validate и BeforeCreate для валидации и хэширования пароля в методе `Create`.

Запустил еще раз тест `TestUserRepository_Create`, чтобы убедиться, что все работает.

## Полезные ссылки
* [REST API на Golang](https://www.youtube.com/playlist?list=PLehOyJfJkFkJ5m37b4oWh783yzVlHdnUH)